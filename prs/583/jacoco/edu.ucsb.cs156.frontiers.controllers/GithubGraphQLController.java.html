<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GithubGraphQLController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">frontiers</a> &gt; <a href="index.source.html" class="el_package">edu.ucsb.cs156.frontiers.controllers</a> &gt; <span class="el_source">GithubGraphQLController.java</span></div><h1>GithubGraphQLController.java</h1><pre class="source lang-java linenums">package edu.ucsb.cs156.frontiers.controllers;

import com.opencsv.bean.StatefulBeanToCsv;
import com.opencsv.exceptions.CsvFieldAssignmentException;
import edu.ucsb.cs156.frontiers.entities.Branch;
import edu.ucsb.cs156.frontiers.entities.BranchId;
import edu.ucsb.cs156.frontiers.entities.Course;
import edu.ucsb.cs156.frontiers.entities.Job;
import edu.ucsb.cs156.frontiers.errors.EntityNotFoundException;
import edu.ucsb.cs156.frontiers.jobs.LoadCommitHistoryJob;
import edu.ucsb.cs156.frontiers.models.CommitDto;
import edu.ucsb.cs156.frontiers.repositories.BranchRepository;
import edu.ucsb.cs156.frontiers.repositories.CommitRepository;
import edu.ucsb.cs156.frontiers.repositories.CourseRepository;
import edu.ucsb.cs156.frontiers.services.GithubGraphQLService;
import edu.ucsb.cs156.frontiers.services.jobs.JobService;
import edu.ucsb.cs156.frontiers.utilities.StatefulBeanToCsvBuilderFactory;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.io.OutputStreamWriter;
import java.time.Instant;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

@Tag(name = &quot;GithubGraphQL&quot;)
@RequestMapping(&quot;/api/github/graphql/&quot;)
@RestController
<span class="fc" id="L43">@Slf4j</span>
public class GithubGraphQLController extends ApiController {

  private final GithubGraphQLService githubGraphQLService;
  private final CourseRepository courseRepository;
  private final JobService jobService;
  private final CommitRepository commitRepository;
  private final StatefulBeanToCsvBuilderFactory statefulBeanToCsvBuilderFactory;
  private final BranchRepository branchRepository;

  public GithubGraphQLController(
      @Autowired GithubGraphQLService gitHubGraphQLService,
      @Autowired CourseRepository courseRepository,
      JobService jobService,
      CommitRepository commitRepository,
      StatefulBeanToCsvBuilderFactory statefulBeanToCsvBuilderFactory,
<span class="fc" id="L59">      BranchRepository branchRepository) {</span>
<span class="fc" id="L60">    this.githubGraphQLService = gitHubGraphQLService;</span>
<span class="fc" id="L61">    this.courseRepository = courseRepository;</span>
<span class="fc" id="L62">    this.jobService = jobService;</span>
<span class="fc" id="L63">    this.statefulBeanToCsvBuilderFactory = statefulBeanToCsvBuilderFactory;</span>
<span class="fc" id="L64">    this.commitRepository = commitRepository;</span>
<span class="fc" id="L65">    this.branchRepository = branchRepository;</span>
<span class="fc" id="L66">  }</span>

  /**
   * Return default branch name for a given repository.
   *
   * @param courseId the id of the course whose installation is being used for credentails
   * @param owner the owner of the repository
   * @param repo the name of the repository
   * @return the default branch name
   */
  @Operation(summary = &quot;Get default branch name&quot;)
  @PreAuthorize(&quot;@CourseSecurity.hasManagePermissions(#root, #courseId)&quot;)
  @GetMapping(&quot;defaultBranchName&quot;)
  public String getDefaultBranchName(
      @Parameter Long courseId, @Parameter String owner, @Parameter String repo) throws Exception {
<span class="fc" id="L81">    log.info(</span>
        &quot;getDefaultBranchName called with courseId: {}, owner: {}, repo: {}&quot;,
        courseId,
        owner,
        repo);
<span class="fc" id="L86">    Course course =</span>
        courseRepository
<span class="fc" id="L88">            .findById(courseId)</span>
<span class="fc" id="L89">            .orElseThrow(() -&gt; new EntityNotFoundException(Course.class, courseId));</span>

<span class="fc" id="L91">    log.info(&quot;Found course: {}&quot;, course);</span>

<span class="fc" id="L93">    log.info(&quot;Current user is authorized to access course: {}&quot;, course.getId());</span>

<span class="fc" id="L95">    String result = this.githubGraphQLService.getDefaultBranchName(course, owner, repo);</span>

<span class="fc" id="L97">    log.info(&quot;Result from getDefaultBranchName: {}&quot;, result);</span>

<span class="fc" id="L99">    return result;</span>
  }

  /**
   * Return default branch name for a given repository.
   *
   * @param courseId the id of the course whose installation is being used for credentails
   * @param owner the owner of the repository
   * @param repo the name of the repository
   * @return the default branch name
   */
  @Operation(summary = &quot;Get commits&quot;)
  @PreAuthorize(&quot;@CourseSecurity.hasManagePermissions(#root, #courseId)&quot;)
  @GetMapping(&quot;commits&quot;)
  public String getCommits(
      @Parameter Long courseId,
      @Parameter String owner,
      @Parameter String repo,
      @Parameter String branch,
      @Parameter Integer first,
      @RequestParam(name = &quot;after&quot;, required = false) @Parameter String after)
      throws Exception {
<span class="fc" id="L121">    log.info(</span>
        &quot;getCommits called with courseId: {}, owner: {}, repo: {}, branch: {}, first: {}, after: {} &quot;,
        courseId,
        owner,
        repo,
        branch,
        first,
        after);
<span class="fc" id="L129">    Course course =</span>
        courseRepository
<span class="fc" id="L131">            .findById(courseId)</span>
<span class="fc" id="L132">            .orElseThrow(() -&gt; new EntityNotFoundException(Course.class, courseId));</span>

<span class="fc" id="L134">    log.info(&quot;Found course: {}&quot;, course);</span>

<span class="fc" id="L136">    log.info(&quot;Current user is authorized to access course: {}&quot;, course.getId());</span>

<span class="fc" id="L138">    String result = this.githubGraphQLService.getCommits(course, owner, repo, branch, first, after);</span>

<span class="fc" id="L140">    log.info(&quot;Result from getCommits: {}&quot;, result);</span>

<span class="fc" id="L142">    return result;</span>
  }

  /**
   * Returns a job to load the commit data of a number of branches
   *
   * @param courseId the id of the course whose installation is being used for credentials
   * @param branches the list of branches to load
   * @return the job identifier
   */
  @Operation(summary = &quot;Get commits&quot;, description = &quot;Loads commit history for the given branches&quot;)
  @PreAuthorize(&quot;@CourseSecurity.hasManagePermissions(#root, #courseId)&quot;)
  @PostMapping(&quot;history&quot;)
  public Job loadCommitHistory(@Parameter Long courseId, @RequestBody List&lt;BranchId&gt; branches) {
<span class="fc" id="L156">    log.debug(</span>
        &quot;Commit History loader called with courseId {} for the following branches: {}&quot;,
        courseId,
        branches);
<span class="fc" id="L160">    Course course =</span>
        courseRepository
<span class="fc" id="L162">            .findById(courseId)</span>
<span class="fc" id="L163">            .orElseThrow(() -&gt; new EntityNotFoundException(Course.class, courseId));</span>

<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (branches.isEmpty()) {</span>
<span class="fc" id="L166">      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;No branches specified&quot;);</span>
    }

    LoadCommitHistoryJob job =
<span class="fc" id="L170">        LoadCommitHistoryJob.builder()</span>
<span class="fc" id="L171">            .course(course)</span>
<span class="fc" id="L172">            .branches(branches)</span>
<span class="fc" id="L173">            .githubService(githubGraphQLService)</span>
<span class="fc" id="L174">            .build();</span>
<span class="fc" id="L175">    return jobService.runAsJob(job);</span>
  }

  @Operation(
      summary = &quot;Get commits as a CSV&quot;,
      description = &quot;Returns preloaded commit history for the given branches as a CSV&quot;)
  @PreAuthorize(&quot;@CourseSecurity.hasManagePermissions(#root, #courseId)&quot;)
  @PostMapping(value = &quot;csv&quot;, produces = &quot;text/csv&quot;)
  public ResponseEntity&lt;StreamingResponseBody&gt; getCommitsCsv(
      @Parameter Long courseId,
      @Parameter Instant start,
      @Parameter Instant end,
      @Parameter Boolean skipMergeCommits,
      @RequestBody List&lt;BranchId&gt; branches)
      throws Exception {

<span class="fc" id="L191">    List&lt;Branch&gt; selectedBranches = branchRepository.findByIdIn(branches);</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">    if (branches.isEmpty()) {</span>
<span class="fc" id="L194">      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;No branches specified&quot;);</span>
    }

<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (start.isAfter(end)) {</span>
<span class="fc" id="L198">      throw new ResponseStatusException(</span>
          HttpStatus.BAD_REQUEST, &quot;Start time must be before end time.&quot;);
    }

<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (selectedBranches.size() != branches.size()) {</span>
<span class="fc" id="L203">      throw new ResponseStatusException(</span>
          HttpStatus.BAD_REQUEST,
          &quot;One or more branches not found; Please load commit history for those branches first.&quot;);
    }

<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (selectedBranches.stream().anyMatch(branch -&gt; branch.getRetrievedTime().isBefore(end))) {</span>
<span class="fc" id="L209">      throw new ResponseStatusException(</span>
          HttpStatus.BAD_REQUEST,
          &quot;One or more branches have not been updated since the requested end time; Please load commit history for those branches first.&quot;);
    }

<span class="fc" id="L214">    StreamingResponseBody stream =</span>
        (outputStream) -&gt; {
<span class="fc" id="L216">          try (var writer = new OutputStreamWriter(outputStream)) {</span>
<span class="fc" id="L217">            StatefulBeanToCsv&lt;CommitDto&gt; csvWriter = statefulBeanToCsvBuilderFactory.build(writer);</span>
            List&lt;CommitDto&gt; commits;
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (skipMergeCommits) {</span>
<span class="fc" id="L220">              commits =</span>
<span class="fc" id="L221">                  commitRepository.findByBranchIdInAndCommitTimeBetweenAndIsMergeCommitEquals(</span>
                      branches, start, end, false);
            } else {
<span class="fc" id="L224">              commits = commitRepository.findByBranchIdInAndCommitTimeBetween(branches, start, end);</span>
            }
            try {
<span class="fc" id="L227">              csvWriter.write(commits);</span>
<span class="fc" id="L228">            } catch (CsvFieldAssignmentException ignored) {</span>
<span class="fc" id="L229">              writer.write(&quot;Error writing CSV file&quot;);</span>
<span class="fc" id="L230">            }</span>
          }
<span class="fc" id="L232">        };</span>

<span class="fc" id="L234">    return ResponseEntity.ok()</span>
<span class="fc" id="L235">        .contentType(MediaType.parseMediaType(&quot;text/csv; charset=UTF-8&quot;))</span>
<span class="fc" id="L236">        .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment;filename=commit_history.csv&quot;)</span>
<span class="fc" id="L237">        .header(HttpHeaders.CONTENT_TYPE, &quot;text/csv; charset=UTF-8&quot;)</span>
<span class="fc" id="L238">        .header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, HttpHeaders.CONTENT_DISPOSITION)</span>
<span class="fc" id="L239">        .body(stream);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>